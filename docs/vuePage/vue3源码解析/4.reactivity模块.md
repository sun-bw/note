## 一、reactive的响应性
在目录2.2中创建了一个测试实例，在该实例中，通过`reactive`方法生命了一个响应性数据，通过`effect`注册了一个函数。

**跟踪**当前代码，看一下`vue`都做了什么
1. `reactive`做了什么？
2. `effect`是什么？

### reactive
1. 触发`reactive`方法
2. 创建`reactive`对象： `return createReactiveObject`
3. 进入`new Proxy`
    * 第一个参数`target`：传入的对象
    * 第二个参数`handle`：`targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers`，`TargetType.COLLECTION = 2，targetType = 1`，所以`handler`为`baseHandlers`
    * 那么`baseHandlers`是什么
4. 在`reactive`方法中可知，`baseHandlers`是触发`createReactiveObject`传递的第三个参数：`mutableHandlers`
![alt text](image/4-1-1.png)
5. `mutableHandlers`是`packages/reactivity/src/baseHandlers.ts`中导出的对象
![alt text](image/4-1-2.png)
6. 到`packages/reactivity/src/baseHandlers.ts`中，`mutableHandlers`是通过`new MutableReactiveHandler()`实现的，`MutableReactiveHandler`继承了`BaseReactiveHandler`,在`BaseReactiveHandler`中的`get`打一个断点，在`MutableReactiveHandler`中的`set`打一个断点
7. 因为`get`和`set`会在**取值**和**赋值的时候**触发，所以当前这两个断点**不会执行**
8. `reactive`方法内执行了`proxyMap.set(target, proxy)`方法
9. 返回了代理对象， `reactive`方法执行完成
10. 上述逻辑可知，对于`reactive`方法：
* 创建`proxy`
* 把`proxy`加到了`proxyMap`里面
* 返回proxy

### effect
#### 1. effect方法
在`packages/reactivity/src/effect.ts`第`440`行，可以找到`effect`方法，在这里给一个断点

#### 2. 执行 `new ReactiveEffect(fn)`
执行 `new ReactiveEffect(fn)`，其中的`fn`就是传入的匿名函数：
![alt text](image/4-1-3.png)
* 这里涉及一个类`ReactiveEffect`
* 分别在`run`和`stop`这个两个方法中**增加点断**
#### 3. 继续执行代码，执行了`run`方法
* 执行`return this.fn`触发fn函数
* `fn`函数就是**传入的匿名函数**，所以：`document.querySelector('#app').innerText = obj.name`
#### 4. `obj`是一个`proxy`，**`obj.name`**会**触发**`getter`，所以接下来会进入到`BaseReactiveHandler`的`get`中
1. 触发了方法:
```js
const res = Reflect.get(target, key, isRef(target) ? target : receiver)
```
2. 当前的`res`是`zhangsan`
![alt text](image/4-1-4.png)
3. 在下面触发了`track`函数：
    ![alt text](image/4-1-5.png)
    * `track`主要为`targetMap`进行赋值
    * 最后执行了`dep.track`
4. `track`的核心逻辑：收集`fn`
#### 5. 最后在`BaseReactiveHandler`中返回了`res（zhangsan）`，整个`effect`执行完成。

### 在页面中两秒之后会修改`obj.name`，此时会触发`setter`：
1. 两秒之后触发`setter`，会进入到`MutableReactiveHandler`的`set`中
2. 创建变量`oldValue = zhangsan`
3. `value = lisi`
4. 执行代码：
    ```js
        const result = Reflect.set(
            target,
            key,
            value,
            isRef(target) ? target : receiver,
        )
    ```
    修改了`obj`的值为`lisi`
5. 触发`trigger(target, TriggerOpTypes.SET, key, value, oldValue)`
![alt text](image/4-1-6.png)
6. `trigger`在这里为**触发**的意思：
    1. 首先执行：`const depsMap = targetMap.get(target)`，`targetMap`即在`track`中的。
    2. 然后执行到：`push(depsMap.get(key))`，即`fn`函数
    3. 然后触发了`notify`
7. `trigger`完成
8. `setter`回调完成
9. `setter`主要做了2件事情：
    * 修改`obj`的值
    * 触发`targetMap`保存`fn`函数

#### 总结
* 跟踪了整个实例中：
    1. `reactive`函数
    2. `effect`函数
    3. `obj.name = xx`表达式

* 三块代码主要做了：
    1. 创建`proxy`
    2. 收集`effect`的依赖
    3. 触发收集的依赖

## 二、框架实现：构建reactive函数，获取proxy实例
整个`reactive`函数，本质上就是返回一个`proxy`实例，
### 1. 创建 packages/reactivity/src/reactive.ts模块：
```js
import { mutableHandlers } from './baseHandlers'

/**
 * 响应性Map缓存对象
 * key：target
 * val：proxy
 */
export const reactiveMap = new WeakMap<object, any>()

/**
 * 为复杂数据类型，创建响应性对象
 * @param target 被代理对象
 * @returns 代理对象
 */
export function reactive(target: object) {
    return createReactiveObject(target, mutableHandlers, reactiveMap)
}

/**
 * 创建响应对象
 * @param target 被代理对象
 * @param baseHandlers handler
 */
function createReactiveObject(
    target: object,
    baseHandlers: ProxyHandler<any>,
    proxyMap: WeakMap<object, any>
) {
    // 如果该实例已经被代理，则直接读取即可
    const existingProxy = proxyMap.get(target)
    if (existingProxy) {
        return existingProxy
    }

    // 未被代理，则创建代理对象
    const proxy = new Proxy(target, baseHandlers)

    // 缓存代理对象
    proxyMap.set(target, proxy)
    return proxy
}

```
### 2. 创建`packages/reactivity/src/baseHandlers.ts`模块
```js
class BaseReactiveHandler implements ProxyHandler<object> {}

class MutableReactiveHandler extends BaseReactiveHandler {}

export const mutableHandlers: ProxyHandler<object> =
/*@__PURE__*/ new MutableReactiveHandler()

```

### 3. 此时已经构建好了一个基本的`reactive`函数，通过**测试案例**测试一下
### 4. 创建`packages/reactivity/src/index.ts`模块，作为`reactivity`的入口模块
```js
export { reactive } from './reactive'
```
### 5. 在`packages/vue/src/index.ts`中，导入`reactive`模块
```js
export { reactive } from '@vue/reactivity'
```
### 6. 执行`npm run build`进行打包，生成`vue.js`
### 7. `packages/vue/examples/reactivity/reactive.html`文件，作为测试实例：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="../../dist/vue.js"></script>
</head>
<body>
    
</body>
<script>
    const { reactive } = Vue;

    const obj = reactive({
        name: '张三'
    })

    console.log(obj)
</script>
</html>
```
### 8. 运行到`Live Server`，打印了一个`proxy`对象实例
### 9. 当前的`reactive`还存在的问题：
1. `WeakMap`是什么？它和`Map`有什么区别？
2. `mutableHandlers`是一个空的，如何实现
3. 每一次测试，都需要打包吗？
