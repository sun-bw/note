import{_ as l,o as s,c as o,a as n,V as e,C as a}from"./chunks/framework.bbb6cb24.js";const t="/note/assets/EventLoop-1.a39e4591.png",p="/note/assets/EventLoop-2.c1c01d76.png",v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScriptPage/9.Event Loop.md","filePath":"JavaScriptPage/9.Event Loop.md","lastUpdated":1717654037000}'),c={name:"JavaScriptPage/9.Event Loop.md"},r=e('<h2 id="一、什么是event-loop" tabindex="-1">一、什么是Event Loop <a class="header-anchor" href="#一、什么是event-loop" aria-label="Permalink to &quot;一、什么是Event Loop&quot;">​</a></h2><ol><li>event loop（事件循环/事件轮询）</li><li>js是单线程运行的，异步要基于回调来实现</li><li>event loop就是异步回调的实现原理</li></ol><h2 id="二、event-loop执行过程" tabindex="-1">二、Event Loop执行过程 <a class="header-anchor" href="#二、event-loop执行过程" aria-label="Permalink to &quot;二、Event Loop执行过程&quot;">​</a></h2><ol><li>同步代码，一行一行放在Call Stack中执行</li><li>遇到异步，会先记录下，在web apis中，等待时机（定时器，网络请求）</li><li>时机到了，就会移动到Callback Queue中</li><li>如果Call Stack为空，即同步代码执行完成，event loop开始工作</li><li>轮询查找Callback Queue，如果有则移动到Call Stack中执行</li><li>然后继续轮询查找 <img src="'+t+`" alt="Alt text"> 示例：</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hi</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cb1</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">cb1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Bye</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><ol><li>执行第一行代码，第一行代码进入调用栈Call Stack中，调用栈执行，打印出hi，然后清空调用栈。</li><li>然后执行第二行，setTimeout，把cb1函数放在定时器中，在webApi中，等待5秒后，进入到Callback Queue中</li><li>执行第三行代码，推入调用栈中，打印bye，清空调用栈</li><li>当Call Stack中没有代码能推进去时（同步代码执行结束），立刻启动event loop机制</li><li>event loop循环，进入到Callback Queue中查找。</li><li>5秒后，定时器把cb1推入Callback Queue中，event loop把cb1推入Call Stack中，进行执行</li></ol><h2 id="三、dom事件和event-loop的关系" tabindex="-1">三、DOM事件和event loop的关系 <a class="header-anchor" href="#三、dom事件和event-loop的关系" aria-label="Permalink to &quot;三、DOM事件和event loop的关系&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">btn1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">提交</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	console.log(&#39;hi&#39;)</span></span>
<span class="line"><span style="color:#A6ACCD;">	$(&#39;#btn1&#39;).click(function (e) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">		console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">button clicked</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	console.log(&#39;Bye&#39;)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>和上面区别为：执行到click时，把回调函数存放到web apis中，等待用户点击，将回调函数推到Callback Queue中 DOM事件，异步都是基于event loop实现的。</p><h2 id="四、微任务和宏任务" tabindex="-1">四、微任务和宏任务 <a class="header-anchor" href="#四、微任务和宏任务" aria-label="Permalink to &quot;四、微任务和宏任务&quot;">​</a></h2><ul><li>微任务microTask</li><li>宏任务macroTask</li></ul><h3 id="_1-什么是宏任务和微任务" tabindex="-1">1. 什么是宏任务和微任务 <a class="header-anchor" href="#_1-什么是宏任务和微任务" aria-label="Permalink to &quot;1. 什么是宏任务和微任务&quot;">​</a></h3><ul><li>宏任务：setTImeout，setInterval，Ajax，DOM事件</li><li>微任务：Promise，async/await</li></ul><p>微任务执行时机比宏任务早</p><h3 id="_2-event-loop和dom渲染的关系" tabindex="-1">2.Event Loop和DOM渲染的关系 <a class="header-anchor" href="#_2-event-loop和dom渲染的关系" aria-label="Permalink to &quot;2.Event Loop和DOM渲染的关系&quot;">​</a></h3><ol><li>在call stack空闲时</li><li>尝试去进行DOM渲染</li><li>然后在触发Event loop</li></ol><h3 id="_3-微任务和宏任务的区别" tabindex="-1">3. 微任务和宏任务的区别 <a class="header-anchor" href="#_3-微任务和宏任务的区别" aria-label="Permalink to &quot;3. 微任务和宏任务的区别&quot;">​</a></h3><ul><li>微任务：DOM渲染前触发，宏任务：DOM渲染后触发</li><li>微任务是es6规定的，宏任务是浏览器规定的</li></ul><h2 id="五、event-loop-执行全过程-区别微任务和宏任务" tabindex="-1">五、Event Loop 执行全过程，区别微任务和宏任务 <a class="header-anchor" href="#五、event-loop-执行全过程-区别微任务和宏任务" aria-label="Permalink to &quot;五、Event Loop 执行全过程，区别微任务和宏任务&quot;">​</a></h2><p>执行微任务时，会放到微任务的队列中。</p>`,20),i=a("p",null,[a("img",{src:p,alt:"Alt text"})],-1);function D(y,F,C,A,d,h){return s(),o("div",null,[r,n(" 1. Call Stack 清空 2. 执行当前的微任务 3. 尝试渲染DOM 4. 触发Event Loop，执行宏任务。 "),i])}const b=l(c,[["render",D]]);export{v as __pageData,b as default};
